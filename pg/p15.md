Here’s a clean, working version in PL/pgSQL. 
I’ve also included a matching table DDL (note `cnt` should be `bigint` because `count(*)` returns `bigint`).

```sql
-- Destination table (adjust schema as needed)
CREATE TABLE IF NOT EXISTS p15 (
  time_start timestamptz NOT NULL,
  time_end   timestamptz NOT NULL,
  cnt        bigint      NOT NULL
);

-- Stored procedure
CREATE OR REPLACE PROCEDURE insert_p15(
  IN start_time timestamptz,
  IN duration   int DEFAULT 15  -- minutes
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_time_end timestamptz := start_time + make_interval(mins => duration);
BEGIN
  INSERT INTO p15 (time_start, time_end, cnt)
  SELECT
    start_time,
    v_time_end,
    COUNT(*)
  FROM b
  WHERE b."time" >= start_time
    AND b."time" <  v_time_end;
END;
$$;

-- Examples:
-- uses default 15 minutes
CALL insert_p15('2025-01-30 13:45');

-- explicit 15 minutes
CALL insert_p15('2025-01-30 13:45', 15);

-- different duration (e.g., 30 minutes)
CALL insert_p15('2025-01-30 13:45', 30);
```

Notes:

* I used `make_interval(mins => duration)` to build the interval safely.
* If your column in `b` is literally named `time`, quoting (`b."time"`) avoids conflicts with the `time` type keyword. Rename it if possible (e.g., `event_time`).
* If you need exactly one row per call even when no rows exist in `b` for that window, wrap `COUNT(*)` in a subquery with `COALESCE`, e.g.:

  ```sql
  INSERT INTO p15 (time_start, time_end, cnt)
  VALUES (
    start_time, v_time_end,
    COALESCE((SELECT COUNT(*) FROM b WHERE b."time" >= start_time AND b."time" < v_time_end), 0)
  );
  ```
