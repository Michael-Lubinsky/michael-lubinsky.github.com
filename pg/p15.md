Here’s a clean, working version in PL/pgSQL. 
I’ve also included a matching table DDL (note `cnt` should be `bigint` because `count(*)` returns `bigint`).

```sql
-- Destination table (adjust schema as needed)
CREATE TABLE IF NOT EXISTS p15 (
  time_start timestamptz NOT NULL,
  time_end   timestamptz NOT NULL,
  cnt        bigint      NOT NULL
);

-- Stored procedure
CREATE OR REPLACE PROCEDURE insert_p15(
  IN start_time timestamptz,
  IN duration   int DEFAULT 15  -- minutes
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_time_end timestamptz := start_time + make_interval(mins => duration);
BEGIN
  INSERT INTO p15 (time_start, time_end, cnt)
  SELECT
    start_time,
    v_time_end,
    COUNT(*)
  FROM b
  WHERE b."time" >= start_time
    AND b."time" <  v_time_end;
END;
$$;

-- Examples:
-- uses default 15 minutes
CALL insert_p15('2025-01-30 13:45');

-- explicit 15 minutes
CALL insert_p15('2025-01-30 13:45', 15);

-- different duration (e.g., 30 minutes)
CALL insert_p15('2025-01-30 13:45', 30);
```

Notes:

* I used `make_interval(mins => duration)` to build the interval safely.
* If your column in `b` is literally named `time`, quoting (`b."time"`) avoids conflicts with the `time` type keyword. Rename it if possible (e.g., `event_time`).
* If you need exactly one row per call even when no rows exist in `b` for that window, wrap `COUNT(*)` in a subquery with `COALESCE`, e.g.:

  ```sql
  INSERT INTO p15 (time_start, time_end, cnt)
  VALUES (
    start_time, v_time_end,
    COALESCE((SELECT COUNT(*) FROM b WHERE b."time" >= start_time AND b."time" < v_time_end), 0)
  );
  ```


  Exactly — when you schedule this procedure in **pg\_cron** to run every 15 minutes, you want it to fill the *previous 15-minute window*.

That means the `start_time` argument should be **“now truncated to 15-min boundary”**, not just `now()` or `now() - 15 minutes`. If you always pass `now() - interval '15 minutes'`, the procedure will drift depending on cron timing.

---

## Best practice: round down to the 15-minute mark

Postgres makes this easy with `date_trunc`:

```sql
-- gives the last 15-minute boundary
SELECT date_trunc('hour', now()) + (extract(minute from now())::int / 15) * interval '15 minutes';
```

Examples:

* At `13:44:21`, this expression = `2025-01-30 13:30:00`.
* At `13:45:00`, this expression = `2025-01-30 13:45:00`.

So your **procedure call** should be:

```sql
CALL insert_p15(
  date_trunc('hour', now()) + (extract(minute from now())::int / 15) * interval '15 minutes'
);
```

This ensures you always load the *correct 15-minute block*, aligned to the quarter-hour.

---

## Cron job definition

If you want it every 15 minutes:

```sql
-- run at minute 0,15,30,45 of each hour
SELECT cron.schedule(
  'insert-p15-job',
  '0,15,30,45 * * * *',
  $$
  CALL insert_p15(
    date_trunc('hour', now()) + (extract(minute from now())::int / 15) * interval '15 minutes'
  )
  $$
);
```

---

## Alternative simple form

If you don’t care about exact quarter-hour alignment (slight drift is acceptable), you *can* do:

```sql
CALL insert_p15(now() - interval '15 minutes');
```

But if pg\_cron starts late or the server lags, you may overlap or skip windows.

---

✅ **Recommendation**: use the `date_trunc + extract` expression so every run computes a **deterministic quarter-hour start\_time**, independent of actual cron trigger time.

---

Do you want me to also adjust your stored procedure so it **auto-defaults `start_time` to the last finished 15-min slot** if you call it without any argument (making the cron call simpler)?

