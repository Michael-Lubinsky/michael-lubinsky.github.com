
### 1. @lru_cache: Memoization with arguments
python

from functools import lru_cache

@lru_cache(maxsize=128)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(35))  # Fast thanks to memoization
✅ Useful for recursive functions with repeated calculations.

2. functools.partial: Pre-filling function arguments
python
Copy
Edit
from functools import partial

def power(base, exponent):
    return base ** exponent

square = partial(power, exponent=2)
cube = partial(power, exponent=3)

print(square(5))  # 25
print(cube(2))    # 8
✅ Creates specialized versions of functions with some args fixed.

3. functools.wraps: Preserve metadata in decorators
python
Copy
Edit
from functools import wraps

def log_call(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with {args} {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@log_call
def greet(name):
    """Greets a person by name."""
    print(f"Hello, {name}")

greet("Alice")
print(greet.__name__)     # Still 'greet'
print(greet.__doc__)      # Preserved docstring
✅ @wraps is essential when writing decorators to preserve function metadata.

4. functools.singledispatch: Function overloading by type
python
Copy
Edit
from functools import singledispatch

@singledispatch
def handle(value):
    print(f"Default handler for {value}")

@handle.register(int)
def _(value):
    print(f"Handling integer: {value}")

@handle.register(str)
def _(value):
    print(f"Handling string: '{value}'")

handle(42)         # Handling integer
handle("Python")   # Handling string
handle(3.14)       # Default handler
✅ Enables type-based function dispatching.

5. functools.total_ordering: Auto-fill rich comparison methods
python
Copy
Edit
from functools import total_ordering

@total_ordering
class Version:
    def __init__(self, major, minor):
        self.major = major
        self.minor = minor

    def __eq__(self, other):
        return (self.major, self.minor) == (other.major, other.minor)

    def __lt__(self, other):
        return (self.major, self.minor) < (other.major, other.minor)

v1 = Version(1, 2)
v2 = Version(1, 3)

print(v1 < v2)   # True
print(v1 >= v2)  # False — generated by @total_ordering
✅ Reduces boilerplate when implementing custom classes with comparisons.

6. Combining partial with a decorator
python
Copy
Edit
from functools import partial, wraps

def log_with_prefix(prefix, func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"{prefix} Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

info_log = partial(log_with_prefix, "[INFO]")
warn_log = partial(log_with_prefix, "[WARN]")

@info_log
def say_hi():
    print("Hi!")

@warn_log
def warn_user():
    print("This is a warning!")

say_hi()
warn_user()
✅ partial lets you create reusable, parameterized decorators.

